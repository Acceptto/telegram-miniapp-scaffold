worker/messageSender.ts
---
import { md } from '@vlad-yakovlev/telegram-md';

interface Telegram {
  sendMessage: (chatId: number | string, text: string, parse_mode?: string, reply_to_message_id?: number) => Promise<any>;
}

interface App {
  telegram: Telegram;
  botName: string;
}

class MessageSender {
  private botName: string;
  private telegram: Telegram;

  constructor(app: App, telegram: Telegram) {
    this.botName = app.botName;
    this.telegram = telegram;
  }

  async sendMessage(chatId: number | string, text: string, reply_to_message_id?: number): Promise<any> {
    return await this.telegram.sendMessage(chatId, text, 'MarkdownV2', reply_to_message_id);
  }

  async sendGreeting(chatId: number | string, replyToMessageId?: number): Promise<any> {
    const message = md`Hello!

${md.bold('Group Meetup Facilitator')} helps you organize group meetups, e. g. in-person events or\
 calls. Here's how it works:

1. Organizer accesses ${md.link('the calendar', `https://t.me/${this.botName}/calendar`)} \
to set options for when the group can meet
2. Organizer receives a link to share with the group
3. Group members vote for the options that work for them
4. Organizer receives a summary of the votes and can pick the best option

And that's it!

Go to ${md.link('the calendar', `https://t.me/${this.botName}/calendar`)} to get started`;

    return await this.sendMessage(chatId, md.build(message), replyToMessageId);
  }

  async sendCalendarLink(chatId: number | string, userName: string, calendarRef: string): Promise<any> {
    const message = md`
Thanks!

You calendar is submitted and is ready to share. Feel free to share the next message \
or just copy the link from it.
    `;

    await this.sendMessage(chatId, md.build(message));

    const linkMessage = md`${userName} uses ${md.bold('Group Meetup Facilitator')} to organize a group meetup!

Please click on the link below to vote for the dates that work for you. You can vote for multiple dates:

${md.link(`https://t.me/${this.botName}/calendar?startapp=${calendarRef}`, `https://t.me/${this.botName}/calendar?startapp=${calendarRef}`)}`;

    return await this.sendMessage(chatId, md.build(linkMessage));
  }
}

export { MessageSender };


---
worker/cryptoUtils.ts
---
export const sha256 = async (body: string): Promise<Uint8Array> => {
	const enc = new TextEncoder();
	const hashBuffer = await crypto.subtle.digest('SHA-256', enc.encode(body));
	return new Uint8Array(hashBuffer);
};

export const hmacSha256 = async (
	body: string,
	secret: string | Uint8Array
): Promise<Uint8Array> => {
	const enc = new TextEncoder();
	const algorithm = { name: 'HMAC', hash: 'SHA-256' };
	if (!(secret instanceof Uint8Array)) {
		secret = enc.encode(secret);
	}
	const key = await crypto.subtle.importKey('raw', secret, algorithm, false, ['sign', 'verify']);

	const signature = await crypto.subtle.sign(algorithm.name, key, enc.encode(body));

	return new Uint8Array(signature);
};

export const hex = (buffer: Uint8Array): string => {
	const hashArray = Array.from(buffer);

	// convert bytes to hex string
	return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
};

export const generateSecret = (bytes: number): string => {
	return hex(crypto.getRandomValues(new Uint8Array(bytes)));
};


---
worker/telegram.ts
---
import { hmacSha256, hex } from './cryptoUtils';

const TELEGRAM_API_BASE_URL = 'https://api.telegram.org/bot';

class TelegramAPI {
	private token: string;
	private apiBaseUrl: string;

	constructor(token: string, useTestApi: boolean = false) {
		this.token = token;
		const testApiAddendum = useTestApi ? 'test/' : '';
		this.apiBaseUrl = `${TELEGRAM_API_BASE_URL}${token}/${testApiAddendum}`;
	}

	async calculateHashes(initData: string): Promise<any> {
		const urlParams = new URLSearchParams(initData);

		const expectedHash = urlParams.get('hash') || '';
		urlParams.delete('hash');
		urlParams.sort();

		let dataCheckString = '';

		for (const [key, value] of urlParams.entries()) {
			dataCheckString += `${key}=${value}\n`;
		}

		dataCheckString = dataCheckString.slice(0, -1);
		let data: any = Object.fromEntries(urlParams);
		data.user = JSON.parse(data.user || 'null');
		data.receiver = JSON.parse(data.receiver || 'null');
		data.chat = JSON.parse(data.chat || 'null');

		const secretKey = await hmacSha256(this.token, 'WebAppData');
		const calculatedHash = hex(await hmacSha256(dataCheckString, secretKey));

		return { expectedHash, calculatedHash, data };
	}

	async getUpdates(lastUpdateId?: number): Promise<any> {
		const url = `${this.apiBaseUrl}getUpdates`;
		const params: any = {};
		if (lastUpdateId) {
			params.offset = lastUpdateId + 1;
		}

		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify(params),
		});
		return response.json();
	}

	async sendMessage(
		chatId: number | string,
		text: string,
		parse_mode?: string,
		reply_to_message_id?: number
	): Promise<any> {
		const url = `${this.apiBaseUrl}sendMessage`;
		const params: any = {
			chat_id: chatId,
			text: text,
		};
		if (parse_mode) {
			params.parse_mode = parse_mode;
		}
		if (reply_to_message_id) {
			params.reply_to_message_id = reply_to_message_id;
		}
		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify(params),
		});
		return response.json();
	}

	async setWebhook(externalUrl: string, secretToken?: string): Promise<any> {
		const params: any = {
			url: externalUrl,
		};
		if (secretToken) {
			params.secret_token = secretToken;
		}
		const url = `${this.apiBaseUrl}setWebhook`;
		const response = await fetch(url, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify(params),
		});
		return response.json();
	}

	async getMe(): Promise<any> {
		const url = `${this.apiBaseUrl}getMe`;
		const response = await fetch(url, {
			method: 'GET',
			headers: {
				'Content-Type': 'application/json',
			},
		});
		return response.json();
	}
}

export { TelegramAPI as Telegram };


---
worker/index.ts
---
import { Router } from 'itty-router';
import { Telegram } from './telegram';
import { Database } from './db';
import { processMessage } from './messageProcessor';
import { MessageSender } from './messageSender';
import { generateSecret, sha256 } from './cryptoUtils';

interface Env {
	TELEGRAM_BOT_TOKEN: string;
	TELEGRAM_USE_TEST_API: boolean;
	DB: any;
	FRONTEND_URL: string;
	INIT_SECRET: string;
}

interface App {
	telegram: Telegram;
	db: Database;
	corsHeaders: Record<string, string>;
	isLocalhost: boolean;
	botName: string | null;
}

// Create a new router
const router = Router();

const handle = async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {
	let telegram = new Telegram(env.TELEGRAM_BOT_TOKEN, env.TELEGRAM_USE_TEST_API);
	let db = new Database(env.DB);
	let corsHeaders = {
		'Access-Control-Allow-Origin': env.FRONTEND_URL,
		'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
		'Access-Control-Allow-Headers': 'Content-Type, Authorization',
		'Access-Control-Max-Age': '86400',
	};
	let isLocalhost = request.headers.get('Host')?.match(/^(localhost|127\.0\.0\.1)/) !== null;
	let botName = await db.getSetting('bot_name');
	if (!botName) {
		let me = await telegram.getMe();
		botName = me.result.username;
		if (botName) {
			// Check if username is not null or undefined
			await db.setSetting('bot_name', botName);
		} else {
			// Handle the case where we couldn't get a valid botName
			console.error('Failed to get bot username');
			botName = null; // or set a default value
		}
	}

	let app: App = { telegram, db, corsHeaders, isLocalhost, botName };

	return await router.handle(request, app, env, ctx);
};

router.get('/', () => {
	return new Response(
		'This telegram bot is deployed correctly. No user-serviceable parts inside.',
		{ status: 200 }
	);
});

router.post('/miniApp/init', async (request: Request, app: App) => {
	const { telegram, db } = app;
	let json = await request.json();
	let initData = json.initData;

	let { expectedHash, calculatedHash, data } = await telegram.calculateHashes(initData);

	if (expectedHash !== calculatedHash) {
		return new Response('Unauthorized', { status: 401, headers: { ...app.corsHeaders } });
	}

	const currentTime = Math.floor(Date.now() / 1000);
	let stalenessSeconds = currentTime - data.auth_date;
	if (stalenessSeconds > 600) {
		return new Response('Stale data, please restart the app', {
			status: 400,
			headers: { ...app.corsHeaders },
		});
	}

	await db.saveUser(data.user, data.auth_date);
	const token = generateSecret(16);
	if (token) {
		const tokenHash = await sha256(token);
		await db.saveToken(data.user.id, tokenHash);

		return new Response(
			JSON.stringify({
				token: token,
				startParam: data.start_param,
				startPage: data.start_param ? 'calendar' : 'home',
				user: await db.getUser(data.user.id),
			}),
			{ status: 200, headers: { ...app.corsHeaders } }
		);
	} else {
		return new Response('Failed to generate token', {
			status: 500,
			headers: { ...app.corsHeaders },
		});
	}
});

router.get('/miniApp/me', async (request: Request, app: App) => {
	const { db } = app;

	let suppliedToken = request.headers.get('Authorization')?.replace('Bearer ', '');
	const tokenHash = await sha256(suppliedToken || '');
	let user = await db.getUserByTokenHash(tokenHash);

	if (user === null) {
		return new Response('Unauthorized', { status: 401 });
	}

	return new Response(JSON.stringify({ user: user }), {
		status: 200,
		headers: { ...app.corsHeaders },
	});
});

router.get('/miniApp/calendar/:ref', async (request: Request, app: App) => {
	const { db } = app;

	let ref = (request as any).params.ref;
	let calendar = await db.getCalendarByRef(ref);

	if (calendar === null) {
		return new Response('Not found', { status: 404 });
	}

	return new Response(JSON.stringify({ calendar: JSON.parse(calendar) }), {
		status: 200,
		headers: { ...app.corsHeaders },
	});
});

router.post('/miniApp/dates', async (request: Request, app: App) => {
	const { db, telegram, botName } = app;

	let suppliedToken = request.headers.get('Authorization')?.replace('Bearer ', '');
	const tokenHash = await sha256(suppliedToken || '');
	let user = await db.getUserByTokenHash(tokenHash);

	if (user === null) {
		return new Response('Unauthorized', { status: 401 });
	}

	let ref = generateSecret(8);
	let json = await request.json();
	let dates = json.dates as string[];
	if (dates.length > 100) {
		return new Response('Too many dates', { status: 400 });
	}
	for (const date of dates) {
		if (!date.match(/^\d{4}-\d{2}-\d{2}$/)) {
			return new Response('Invalid date', { status: 400 });
		}
	}

	let jsonToSave = JSON.stringify({ dates: json.dates });
	await db.saveCalendar(jsonToSave, ref, user.id);

	let messageSender = new MessageSender(app, telegram);
	await messageSender.sendCalendarLink(user.telegramId, user.firstName, ref);

	return new Response(JSON.stringify({ user: user }), {
		status: 200,
		headers: { ...app.corsHeaders },
	});
});

router.post('/telegramMessage', async (request: Request, app: App) => {
	const { db } = app;
	const telegramProvidedToken = request.headers.get('X-Telegram-Bot-Api-Secret-Token');
	const savedToken = await db.getSetting('telegram_security_code');

	if (telegramProvidedToken !== savedToken) {
		return new Response('Unauthorized', { status: 401 });
	}

	let messageJson = await request.json();
	await processMessage(messageJson, app);

	return new Response('Success', { status: 200 });
});

router.get('/updateTelegramMessages', async (request: Request, app: App, env: Env) => {
	if (!app.isLocalhost) {
		return new Response('This request is only supposed to be used locally', { status: 403 });
	}

	const { telegram, db } = app;
	let lastUpdateId = await db.getLatestUpdateId();
	let updates = await telegram.getUpdates(lastUpdateId);
	let results = [];
	for (const update of updates.result) {
		let result = await processMessage(update, app);
		results.push(result);
	}

	return new Response(
		`Success!
  Last update id:
  ${lastUpdateId}\n\n
  Updates:
  ${JSON.stringify(updates, null, 2)}\n\n
  Results:
  ${JSON.stringify(results, null, 2)}`,
		{ status: 200 }
	);
});

router.post('/init', async (request: Request, app: App, env: Env) => {
	if (request.headers.get('Authorization') !== `Bearer ${env.INIT_SECRET}`) {
		return new Response('Unauthorized', { status: 401 });
	}

	const { telegram, db, botName } = app;

	let token = await db.getSetting('telegram_security_code');

	if (token === null) {
		token = crypto.getRandomValues(new Uint8Array(16)).join('');
		await db.setSetting('telegram_security_code', token);
	}

	let json = await request.json();
	let externalUrl = json.externalUrl;

	let response = await telegram.setWebhook(`${externalUrl}/telegramMessage`, token);

	return new Response(
		`Success! Bot Name: https://t.me/${botName}. Webhook status:  ${JSON.stringify(response)}`,
		{ status: 200 }
	);
});

router.options(
	'/miniApp/*',
	(request: Request, app: App, env: Env) =>
		new Response('Success', {
			headers: {
				...app.corsHeaders,
			},
			status: 200,
		})
);

router.all('*', () => new Response('404, not found!', { status: 404 }));

export default {
	fetch: handle,
};


---
worker/db.ts
---
class Database {
	private db: any;

	constructor(databaseConnection: any) {
		this.db = databaseConnection;
	}

	async getSetting(settingName: string): Promise<string | null> {
		return await this.db
			.prepare('SELECT value FROM settings WHERE name = ?')
			.bind(settingName)
			.first('value');
	}

	async getLatestUpdateId(): Promise<number> {
		let result = await this.db
			.prepare('SELECT updateId FROM messages ORDER BY updateId DESC LIMIT 1')
			.first('updateId');

		return Number(result);
	}

	async setSetting(settingName: string, settingValue: string): Promise<any> {
		return await this.db
			.prepare(
				`INSERT
        INTO settings (createdDate, updatedDate, name, value)
        VALUES (DATETIME('now'), DATETIME('now'), ?, ?)
        ON CONFLICT(name) DO UPDATE SET
          updatedDate = DATETIME('now'),
          value = excluded.value
          WHERE excluded.value <> settings.value`
			)
			.bind(settingName, settingValue)
			.run();
	}

	async addMessage(message: string, updateId: number): Promise<any> {
		return await this.db
			.prepare(
				`INSERT
        INTO messages (createdDate, updatedDate, message, updateId)
        VALUES (DATETIME('now'), DATETIME('now'), ?, ?)`
			)
			.bind(message, updateId)
			.run();
	}

	async getUser(telegramId: number): Promise<any> {
		return await this.db
			.prepare('SELECT * FROM users WHERE telegramId = ?')
			.bind(telegramId)
			.first();
	}

	async saveUser(user: any, authTimestamp: number): Promise<any> {
		return await this.db
			.prepare(
				`INSERT
        INTO users (createdDate, updatedDate, lastAuthTimestamp,
          telegramId, isBot, firstName, lastName, username, languageCode,
          isPremium, addedToAttachmentMenu, allowsWriteToPm, photoUrl
          )
        VALUES (DATETIME('now'), DATETIME('now'), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(telegramId) DO UPDATE SET
          updatedDate = DATETIME('now'),
          lastAuthTimestamp = COALESCE(excluded.lastAuthTimestamp, lastAuthTimestamp),
          isBot = COALESCE(excluded.isBot, isBot),
          firstName = excluded.firstName,
          lastName = excluded.lastName,
          username = excluded.username,
          languageCode = COALESCE(excluded.languageCode, languageCode),
          isPremium = COALESCE(excluded.isPremium, isPremium),
          addedToAttachmentMenu = COALESCE(excluded.addedToAttachmentMenu, addedToAttachmentMenu),
          allowsWriteToPm = COALESCE(excluded.allowsWriteToPm, allowsWriteToPm),
          photoUrl = COALESCE(excluded.photoUrl, photoUrl)
          WHERE excluded.lastAuthTimestamp > users.lastAuthTimestamp`
			)
			.bind(
				authTimestamp,
				user.id,
				+user.is_bot,
				user.first_name || null,
				user.last_name || null,
				user.username || null,
				user.language_code || null,
				+user.is_premium,
				+user.added_to_attachment_menu,
				+user.allows_write_to_pm,
				user.photo_url || null
			)
			.run();
	}

	async saveToken(telegramId: number, tokenHash: Uint8Array): Promise<any> {
		const user = await this.getUser(telegramId);
		return await this.db
			.prepare(
				`INSERT
        INTO tokens (createdDate, updatedDate, expiredDate, userId, tokenHash)
        VALUES (DATETIME('now'), DATETIME('now'), DATETIME('now', '+1 day'), ?, ?)`
			)
			.bind(user.id, tokenHash)
			.run();
	}

	async getUserByTokenHash(tokenHash: Uint8Array): Promise<any> {
		return await this.db
			.prepare(
				`SELECT users.* FROM tokens
        INNER JOIN users ON tokens.userId = users.id
        WHERE tokenHash = ? AND DATETIME('now') < expiredDate`
			)
			.bind(tokenHash)
			.first();
	}

	async saveCalendar(calendarJson: string, calendarRef: string, userId: number): Promise<any> {
		return await this.db
			.prepare(
				`INSERT
        INTO calendars (createdDate, updatedDate, calendarJson, calendarRef, userId)
        VALUES (DATETIME('now'), DATETIME('now'), ?, ?, ?)`
			)
			.bind(calendarJson, calendarRef, userId)
			.run();
	}

	async getCalendarByRef(calendarRef: string): Promise<string | null> {
		return await this.db
			.prepare(
				`SELECT calendarJson FROM calendars
        WHERE calendarRef = ?`
			)
			.bind(calendarRef)
			.first('calendarJson');
	}
}

export { Database };


---
worker/messageProcessor.ts
---
import { MessageSender } from './messageSender';

// Define interfaces
interface TelegramMessage {
	chat: {
		id: number;
	};
	message_id: number;
	text?: string;
}

interface TelegramUpdate {
	message: TelegramMessage;
	update_id: number;
}

interface Database {
	addMessage: (message: string, updateId: number) => Promise<void>;
}

interface Telegram {
	calculateHashes: (initData: string) => Promise<{
		expectedHash: string;
		calculatedHash: string;
		data: Record<string, any>;
	}>;
	getUpdates: (lastUpdateId?: number) => Promise<any>; // We can refine this return type later
	sendMessage: (
		chatId: number | string,
		text: string,
		parse_mode?: string,
		reply_to_message_id?: number
	) => Promise<any>;
	setWebhook: (externalUrl: string, secretToken?: string) => Promise<any>;
	getMe: () => Promise<any>;
}

interface App {
	telegram: Telegram;
	db: Database;
}

const processMessage = async (json: TelegramUpdate, app: App): Promise<string> => {
	const { telegram, db } = app;

	const messageSender = new MessageSender(app, telegram);

	const chatId = json.message.chat.id;
	const replyToMessageId = json.message.message_id;

	const messageToSave = JSON.stringify(json, null, 2);
	await db.addMessage(messageToSave, json.update_id);

	if (json.message.text === '/start') {
		return await messageSender.sendGreeting(chatId, replyToMessageId);
	}

	return 'Skipped message';
};

export { processMessage };


---
worker/locales/en.md
---


---
worker/sql/drop.sql
---
DROP TABLE IF EXISTS settings;
DROP TABLE IF EXISTS messages;
DROP TABLE IF EXISTS initDataCheck;
DROP TABLE IF EXISTS tokens;
DROP TABLE IF EXISTS calendars;
DROP TABLE IF EXISTS users;

---
worker/sql/init.sql
---
CREATE TABLE IF NOT EXISTS settings (
	name text PRIMARY KEY,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	value text NOT NULL
);

CREATE TABLE IF NOT EXISTS messages (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	message text NOT NULL,
	updateId text NOT NULL
);

CREATE TABLE IF NOT EXISTS initDataCheck (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	initData text NOT NULL,
	expectedHash text NOT NULL,
	calculatedHash text NOT NULL
);

CREATE TABLE IF NOT EXISTS users (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	lastAuthTimestamp text NOT NULL,
	telegramId integer UNIQUE NOT NULL,
	username text,
	isBot integer,
	firstName text,
	lastName text,
	languageCode text,
	isPremium integer,
	addedToAttachmentMenu integer,
	allowsWriteToPm integer,
	photoUrl text
);

CREATE TABLE IF NOT EXISTS tokens (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	expiredDate text NOT NULL,
	tokenHash text UNIQUE NOT NULL,
	userId integer NOT NULL,
	FOREIGN KEY(userId) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS calendars (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	userId integer NOT NULL,
	calendarJson text NOT NULL,
	calendarRef text NOT NULL,
	FOREIGN KEY(userId) REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS selectedDates (
	id integer PRIMARY KEY AUTOINCREMENT,
	createdDate text NOT NULL,
	updatedDate text NOT NULL,
	userId integer NOT NULL,
	calendarId integer NOT NULL,
	selectedDatesJson text NOT NULL,
	FOREIGN KEY(userId) REFERENCES users(id),
	FOREIGN KEY(calendarId) REFERENCES calendars(id)
);

CREATE UNIQUE INDEX IF NOT EXISTS userSelectedDatesIndex ON selectedDates (userId, calendarId);

CREATE UNIQUE INDEX IF NOT EXISTS tokenHashIndex ON tokens (tokenHash);
CREATE UNIQUE INDEX IF NOT EXISTS telegramIdIndex ON users (telegramId);

---
